<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Audio Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid #3a3a3a;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-label {
            font-size: 11px;
            color: #888;
            margin-right: 4px;
        }

        button {
            background-color: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.15s;
        }

        button:hover:not(:disabled) {
            background-color: #4a4a4a;
        }

        button:active:not(:disabled) {
            background-color: #5a5a5a;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background-color: #2563eb;
            border-color: #3b82f6;
        }

        button.primary:hover:not(:disabled) {
            background-color: #3b82f6;
        }

        button.transport {
            width: 40px;
            font-size: 16px;
            padding: 6px;
        }

        button.transport.playing {
            background-color: #059669;
            border-color: #10b981;
        }

        /* Waveform container */
        .waveform-container {
            flex: 1;
            position: relative;
            background-color: #1a1a1a;
            overflow: hidden;
            min-height: 200px;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Selection info overlay */
        .selection-info {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }

        .selection-info.visible {
            display: block;
        }

        /* Status bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 6px 12px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            font-size: 12px;
            color: #888;
        }

        .status-bar .info {
            display: flex;
            gap: 16px;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
        }

        .modal h3 {
            margin-bottom: 16px;
            font-weight: 500;
        }

        .modal-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
        }

        .modal-row label {
            flex: 0 0 100px;
            font-size: 13px;
        }

        .modal-row select,
        .modal-row input {
            flex: 1;
            background-color: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 20px;
        }

        /* Hidden file input */
        #fileInput {
            display: none;
        }

        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            font-size: 11px;
            color: #666;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".wav,.aif,.aiff">

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-group">
            <span class="toolbar-label">File</span>
            <button id="importBtn">Import</button>
            <button id="exportBtn" disabled>Export</button>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Transport</span>
            <button id="playBtn" class="transport" disabled title="Play (Space)">&#9654;</button>
            <button id="pauseBtn" class="transport" disabled title="Pause (Space)">&#10074;&#10074;</button>
            <button id="stopBtn" class="transport" disabled title="Stop">&#9632;</button>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Zoom</span>
            <button id="zoomInBtn" disabled title="Zoom In (+)">+</button>
            <button id="zoomOutBtn" disabled title="Zoom Out (-)">-</button>
            <button id="zoomFitBtn" disabled title="Fit to Window">Fit</button>
            <span class="shortcuts-hint">Shift+Scroll to zoom</span>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Edit</span>
            <button id="trimBtn" disabled title="Trim to selection">Trim</button>
            <button id="normalizeBtn" disabled title="Normalize">Normalize</button>
            <button id="fadeInBtn" disabled title="Fade In">Fade In</button>
            <button id="fadeOutBtn" disabled title="Fade Out">Fade Out</button>
            <button id="gainBtn" disabled title="Apply Gain">Gain</button>
        </div>
    </div>

    <!-- Waveform -->
    <div class="waveform-container">
        <canvas id="waveformCanvas"></canvas>
        <div class="selection-info" id="selectionInfo"></div>
    </div>

    <!-- Status bar -->
    <div class="status-bar">
        <div class="info">
            <span id="fileInfo">No file loaded</span>
            <span id="positionInfo"></span>
        </div>
        <span id="zoomInfo"></span>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h3>Export Audio</h3>
            <div class="modal-row">
                <label>Format</label>
                <select id="exportFormat">
                    <option value="wav">WAV</option>
                    <option value="aif">AIF</option>
                </select>
            </div>
            <div class="modal-row">
                <label>Bit Depth</label>
                <select id="exportBitDepth">
                    <option value="16">16-bit</option>
                    <option value="24">24-bit</option>
                    <option value="32">32-bit float</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="exportCancelBtn">Cancel</button>
                <button id="exportConfirmBtn" class="primary">Export</button>
            </div>
        </div>
    </div>

    <!-- Normalize Modal -->
    <div class="modal-overlay" id="normalizeModal">
        <div class="modal">
            <h3>Normalize</h3>
            <div class="modal-row">
                <label>Peak Level (dBFS)</label>
                <input type="number" id="normalizeLevel" value="0" min="-60" max="0" step="0.1">
            </div>
            <div class="modal-buttons">
                <button id="normalizeCancelBtn">Cancel</button>
                <button id="normalizeConfirmBtn" class="primary">Apply</button>
            </div>
        </div>
    </div>

    <!-- Gain Modal -->
    <div class="modal-overlay" id="gainModal">
        <div class="modal">
            <h3>Apply Gain</h3>
            <div class="modal-row">
                <label>Gain (dB)</label>
                <input type="number" id="gainAmount" value="0" min="-60" max="60" step="0.1">
            </div>
            <div class="modal-buttons">
                <button id="gainCancelBtn">Cancel</button>
                <button id="gainConfirmBtn" class="primary">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== Audio Engine ====================
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.sourceNode = null;
                this.isPlaying = false;
                this.isPaused = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.onPlaybackEnd = null;
                this.onPositionUpdate = null;
                this.animationFrame = null;
            }

            async init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            async loadAudio(arrayBuffer) {
                await this.init();
                this.stop();
                this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                return this.audioBuffer;
            }

            play(startOffset = 0) {
                if (!this.audioBuffer) return;

                this.stop();
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = this.audioBuffer;
                this.sourceNode.connect(this.audioContext.destination);

                this.sourceNode.onended = () => {
                    if (this.isPlaying && !this.isPaused) {
                        this.stop();
                        if (this.onPlaybackEnd) this.onPlaybackEnd();
                    }
                };

                const offset = this.isPaused ? this.pauseTime : startOffset;
                this.sourceNode.start(0, offset);
                this.startTime = this.audioContext.currentTime - offset;
                this.isPlaying = true;
                this.isPaused = false;

                this.updatePosition();
            }

            pause() {
                if (!this.isPlaying || this.isPaused) return;
                this.pauseTime = this.getCurrentTime();
                this.sourceNode.stop();
                this.isPaused = true;
                this.isPlaying = false;
                cancelAnimationFrame(this.animationFrame);
            }

            stop() {
                if (this.sourceNode) {
                    try {
                        this.sourceNode.stop();
                    } catch (e) {}
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }
                this.isPlaying = false;
                this.isPaused = false;
                this.pauseTime = 0;
                cancelAnimationFrame(this.animationFrame);
            }

            getCurrentTime() {
                if (this.isPaused) return this.pauseTime;
                if (!this.isPlaying) return 0;
                return this.audioContext.currentTime - this.startTime;
            }

            getDuration() {
                return this.audioBuffer ? this.audioBuffer.duration : 0;
            }

            updatePosition() {
                if (!this.isPlaying) return;
                if (this.onPositionUpdate) {
                    this.onPositionUpdate(this.getCurrentTime());
                }
                this.animationFrame = requestAnimationFrame(() => this.updatePosition());
            }

            setBuffer(buffer) {
                this.stop();
                this.audioBuffer = buffer;
            }
        }

        // ==================== Waveform Renderer ====================
        class WaveformRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.audioBuffer = null;
                this.samplesPerPixel = 100;
                this.scrollOffset = 0;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.playheadPosition = 0;
                this.peaks = null;
                this.isDragging = false;
                this.dragStart = 0;

                this.setupResize();
                this.setupInteraction();
            }

            setupResize() {
                const resizeObserver = new ResizeObserver(() => this.resize());
                resizeObserver.observe(this.canvas.parentElement);
                this.resize();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                this.render();
            }

            setupInteraction() {
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
            }

            onMouseDown(e) {
                if (!this.audioBuffer) return;
                this.isDragging = true;
                const x = e.offsetX;
                this.dragStart = x;
                this.selectionStart = this.pixelToSample(x);
                this.selectionEnd = this.selectionStart;
                this.render();
            }

            onMouseMove(e) {
                if (!this.isDragging || !this.audioBuffer) return;
                const x = e.offsetX;
                this.selectionEnd = this.pixelToSample(x);
                this.render();
                this.updateSelectionInfo();
            }

            onMouseUp(e) {
                if (!this.isDragging) return;
                this.isDragging = false;

                // Normalize selection (start < end)
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    if (this.selectionStart > this.selectionEnd) {
                        [this.selectionStart, this.selectionEnd] = [this.selectionEnd, this.selectionStart];
                    }
                    // Clear selection if too small
                    if (this.selectionEnd - this.selectionStart < 10) {
                        this.selectionStart = null;
                        this.selectionEnd = null;
                    }
                }
                this.render();
                this.updateSelectionInfo();
                if (this.onSelectionChange) this.onSelectionChange();
            }

            onWheel(e) {
                if (!this.audioBuffer) return;
                if (e.shiftKey) {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8;
                    const mouseX = e.offsetX;
                    const sampleAtMouse = this.pixelToSample(mouseX);

                    this.samplesPerPixel = Math.max(1, Math.min(
                        this.audioBuffer.length / 100,
                        this.samplesPerPixel * zoomFactor
                    ));

                    // Adjust scroll to keep sample under mouse
                    this.scrollOffset = sampleAtMouse - mouseX * this.samplesPerPixel;
                    this.clampScroll();
                    this.calculatePeaks();
                    this.render();
                    if (this.onZoomChange) this.onZoomChange();
                }
            }

            setAudioBuffer(buffer) {
                this.audioBuffer = buffer;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.scrollOffset = 0;
                this.zoomFit();
            }

            zoomFit() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = this.audioBuffer.length / this.width;
                this.scrollOffset = 0;
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            zoomIn() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = Math.max(1, this.samplesPerPixel * 0.5);
                this.clampScroll();
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            zoomOut() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = Math.min(
                    this.audioBuffer.length / 100,
                    this.samplesPerPixel * 2
                );
                this.clampScroll();
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            clampScroll() {
                const maxScroll = Math.max(0, this.audioBuffer.length - this.width * this.samplesPerPixel);
                this.scrollOffset = Math.max(0, Math.min(maxScroll, this.scrollOffset));
            }

            pixelToSample(x) {
                return Math.floor(this.scrollOffset + x * this.samplesPerPixel);
            }

            sampleToPixel(sample) {
                return (sample - this.scrollOffset) / this.samplesPerPixel;
            }

            calculatePeaks() {
                if (!this.audioBuffer) return;

                const channelData = this.audioBuffer.getChannelData(0);
                const numPeaks = Math.ceil(this.width);
                this.peaks = new Float32Array(numPeaks * 2);

                for (let i = 0; i < numPeaks; i++) {
                    const startSample = Math.floor(this.scrollOffset + i * this.samplesPerPixel);
                    const endSample = Math.floor(startSample + this.samplesPerPixel);

                    let min = 0, max = 0;
                    for (let j = startSample; j < endSample && j < channelData.length; j++) {
                        if (j >= 0) {
                            const value = channelData[j];
                            if (value < min) min = value;
                            if (value > max) max = value;
                        }
                    }
                    this.peaks[i * 2] = min;
                    this.peaks[i * 2 + 1] = max;
                }
            }

            setPlayheadPosition(time) {
                if (!this.audioBuffer) return;
                const sample = Math.floor(time * this.audioBuffer.sampleRate);
                this.playheadPosition = sample;
                this.render();
            }

            getSelection() {
                if (this.selectionStart === null || this.selectionEnd === null) return null;
                return {
                    start: Math.min(this.selectionStart, this.selectionEnd),
                    end: Math.max(this.selectionStart, this.selectionEnd)
                };
            }

            hasSelection() {
                return this.selectionStart !== null && this.selectionEnd !== null;
            }

            updateSelectionInfo() {
                const info = document.getElementById('selectionInfo');
                const selection = this.getSelection();
                if (!selection || !this.audioBuffer) {
                    info.classList.remove('visible');
                    return;
                }

                const startTime = selection.start / this.audioBuffer.sampleRate;
                const endTime = selection.end / this.audioBuffer.sampleRate;
                const duration = endTime - startTime;

                info.textContent = `Selection: ${formatTime(startTime)} - ${formatTime(endTime)} (${formatTime(duration)})`;
                info.classList.add('visible');
            }

            render() {
                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;

                // Clear
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);

                if (!this.audioBuffer || !this.peaks) {
                    // Draw placeholder text
                    ctx.fillStyle = '#444';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Import an audio file to begin', width / 2, height / 2);
                    return;
                }

                const centerY = height / 2;
                const amplitude = height / 2 - 10;

                // Draw selection
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    const startX = this.sampleToPixel(Math.min(this.selectionStart, this.selectionEnd));
                    const endX = this.sampleToPixel(Math.max(this.selectionStart, this.selectionEnd));
                    ctx.fillStyle = 'rgba(37, 99, 235, 0.3)';
                    ctx.fillRect(startX, 0, endX - startX, height);
                }

                // Draw center line
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                // Draw waveform
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < this.peaks.length / 2; i++) {
                    const min = this.peaks[i * 2];
                    const max = this.peaks[i * 2 + 1];
                    const y1 = centerY - max * amplitude;
                    const y2 = centerY - min * amplitude;
                    ctx.fillRect(i, y1, 1, Math.max(1, y2 - y1));
                }

                // Draw playhead
                const playheadX = this.sampleToPixel(this.playheadPosition);
                if (playheadX >= 0 && playheadX <= width) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                }
            }
        }

        // ==================== File Handler ====================
        class FileHandler {
            static async importFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsArrayBuffer(file);
                });
            }

            static exportWAV(audioBuffer, bitDepth = 16) {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const length = audioBuffer.length;

                let bytesPerSample;
                let formatCode;
                if (bitDepth === 32) {
                    bytesPerSample = 4;
                    formatCode = 3; // Float
                } else {
                    bytesPerSample = bitDepth / 8;
                    formatCode = 1; // PCM
                }

                const dataSize = length * numChannels * bytesPerSample;
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);

                // RIFF header
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataSize, true);
                this.writeString(view, 8, 'WAVE');

                // fmt chunk
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // chunk size
                view.setUint16(20, formatCode, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
                view.setUint16(32, numChannels * bytesPerSample, true);
                view.setUint16(34, bitDepth, true);

                // data chunk
                this.writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);

                // Write samples
                const channels = [];
                for (let c = 0; c < numChannels; c++) {
                    channels.push(audioBuffer.getChannelData(c));
                }

                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let c = 0; c < numChannels; c++) {
                        const sample = channels[c][i];
                        if (bitDepth === 32) {
                            view.setFloat32(offset, sample, true);
                        } else if (bitDepth === 24) {
                            const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFFFF;
                            view.setUint8(offset, intSample & 0xFF);
                            view.setUint8(offset + 1, (intSample >> 8) & 0xFF);
                            view.setUint8(offset + 2, (intSample >> 16) & 0xFF);
                        } else {
                            const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFF;
                            view.setInt16(offset, intSample, true);
                        }
                        offset += bytesPerSample;
                    }
                }

                return new Blob([buffer], { type: 'audio/wav' });
            }

            static exportAIF(audioBuffer, bitDepth = 16) {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const length = audioBuffer.length;
                const bytesPerSample = bitDepth / 8;

                const dataSize = length * numChannels * bytesPerSample;
                const commSize = 18;
                const ssndSize = 8 + dataSize;
                const formSize = 4 + 8 + commSize + 8 + ssndSize;

                const buffer = new ArrayBuffer(12 + 8 + commSize + 8 + ssndSize);
                const view = new DataView(buffer);

                // FORM header
                this.writeString(view, 0, 'FORM');
                view.setUint32(4, formSize, false);
                this.writeString(view, 8, 'AIFF');

                // COMM chunk
                this.writeString(view, 12, 'COMM');
                view.setUint32(16, commSize, false);
                view.setInt16(20, numChannels, false);
                view.setUint32(22, length, false);
                view.setInt16(26, bitDepth, false);
                // Sample rate as 80-bit extended float (simplified)
                this.writeExtendedFloat(view, 28, sampleRate);

                // SSND chunk
                const ssndOffset = 12 + 8 + commSize;
                this.writeString(view, ssndOffset, 'SSND');
                view.setUint32(ssndOffset + 4, ssndSize, false);
                view.setUint32(ssndOffset + 8, 0, false); // offset
                view.setUint32(ssndOffset + 12, 0, false); // block size

                // Write samples
                const channels = [];
                for (let c = 0; c < numChannels; c++) {
                    channels.push(audioBuffer.getChannelData(c));
                }

                let offset = ssndOffset + 16;
                for (let i = 0; i < length; i++) {
                    for (let c = 0; c < numChannels; c++) {
                        const sample = channels[c][i];
                        if (bitDepth === 24) {
                            const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFFFF;
                            view.setUint8(offset, (intSample >> 16) & 0xFF);
                            view.setUint8(offset + 1, (intSample >> 8) & 0xFF);
                            view.setUint8(offset + 2, intSample & 0xFF);
                        } else if (bitDepth === 32) {
                            const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFFFFFF;
                            view.setInt32(offset, intSample, false);
                        } else {
                            const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFF;
                            view.setInt16(offset, intSample, false);
                        }
                        offset += bytesPerSample;
                    }
                }

                return new Blob([buffer], { type: 'audio/aiff' });
            }

            static writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            static writeExtendedFloat(view, offset, value) {
                // Simplified 80-bit extended float for sample rate
                let exponent = 16398;
                let mantissa = value;
                while (mantissa < 32768) {
                    mantissa *= 2;
                    exponent--;
                }
                view.setUint16(offset, exponent, false);
                view.setUint32(offset + 2, mantissa * 65536, false);
                view.setUint32(offset + 6, 0, false);
            }
        }

        // ==================== Audio Editor ====================
        class AudioEditor {
            constructor(audioContext) {
                this.audioContext = audioContext;
            }

            createBuffer(length, numChannels, sampleRate) {
                return this.audioContext.createBuffer(numChannels, length, sampleRate);
            }

            trim(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const newLength = endSample - startSample;

                const newBuffer = this.createBuffer(newLength, numChannels, sampleRate);

                for (let c = 0; c < numChannels; c++) {
                    const oldData = audioBuffer.getChannelData(c);
                    const newData = newBuffer.getChannelData(c);
                    for (let i = 0; i < newLength; i++) {
                        newData[i] = oldData[startSample + i];
                    }
                }

                return newBuffer;
            }

            normalize(audioBuffer, targetDbFS = 0, startSample = 0, endSample = null) {
                if (endSample === null) endSample = audioBuffer.length;
                const numChannels = audioBuffer.numberOfChannels;

                // Find peak
                let peak = 0;
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        const abs = Math.abs(data[i]);
                        if (abs > peak) peak = abs;
                    }
                }

                if (peak === 0) return audioBuffer;

                // Calculate gain
                const targetLinear = Math.pow(10, targetDbFS / 20);
                const gain = targetLinear / peak;

                // Apply gain
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        data[i] *= gain;
                    }
                }

                return audioBuffer;
            }

            fadeIn(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const fadeLength = endSample - startSample;

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < fadeLength; i++) {
                        const gain = i / fadeLength;
                        data[startSample + i] *= gain;
                    }
                }

                return audioBuffer;
            }

            fadeOut(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const fadeLength = endSample - startSample;

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < fadeLength; i++) {
                        const gain = 1 - (i / fadeLength);
                        data[startSample + i] *= gain;
                    }
                }

                return audioBuffer;
            }

            applyGain(audioBuffer, gainDb, startSample = 0, endSample = null) {
                if (endSample === null) endSample = audioBuffer.length;
                const numChannels = audioBuffer.numberOfChannels;
                const gainLinear = Math.pow(10, gainDb / 20);

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        data[i] = Math.max(-1, Math.min(1, data[i] * gainLinear));
                    }
                }

                return audioBuffer;
            }
        }

        // ==================== Utility Functions ====================
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins}:${secs.padStart(5, '0')}`;
        }

        // ==================== Main Application ====================
        class App {
            constructor() {
                this.audioEngine = new AudioEngine();
                this.waveformRenderer = new WaveformRenderer(document.getElementById('waveformCanvas'));
                this.audioEditor = null;
                this.fileName = null;

                this.setupEventListeners();
                this.updateUI();
            }

            setupEventListeners() {
                // File operations
                document.getElementById('importBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files[0]) this.importFile(e.target.files[0]);
                });
                document.getElementById('exportBtn').addEventListener('click', () => this.showExportModal());

                // Transport
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());

                // Zoom
                document.getElementById('zoomInBtn').addEventListener('click', () => this.waveformRenderer.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.waveformRenderer.zoomOut());
                document.getElementById('zoomFitBtn').addEventListener('click', () => this.waveformRenderer.zoomFit());

                // Edit operations
                document.getElementById('trimBtn').addEventListener('click', () => this.trim());
                document.getElementById('normalizeBtn').addEventListener('click', () => this.showNormalizeModal());
                document.getElementById('fadeInBtn').addEventListener('click', () => this.fadeIn());
                document.getElementById('fadeOutBtn').addEventListener('click', () => this.fadeOut());
                document.getElementById('gainBtn').addEventListener('click', () => this.showGainModal());

                // Export modal
                document.getElementById('exportCancelBtn').addEventListener('click', () => this.hideExportModal());
                document.getElementById('exportConfirmBtn').addEventListener('click', () => this.exportFile());

                // Normalize modal
                document.getElementById('normalizeCancelBtn').addEventListener('click', () => this.hideNormalizeModal());
                document.getElementById('normalizeConfirmBtn').addEventListener('click', () => this.normalize());

                // Gain modal
                document.getElementById('gainCancelBtn').addEventListener('click', () => this.hideGainModal());
                document.getElementById('gainConfirmBtn').addEventListener('click', () => this.applyGain());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));

                // Waveform callbacks
                this.waveformRenderer.onSelectionChange = () => this.updateUI();
                this.waveformRenderer.onZoomChange = () => this.updateZoomInfo();

                // Playback callbacks
                this.audioEngine.onPositionUpdate = (time) => {
                    this.waveformRenderer.setPlayheadPosition(time);
                    this.updatePositionInfo(time);
                };
                this.audioEngine.onPlaybackEnd = () => {
                    this.updateUI();
                };
            }

            handleKeyboard(e) {
                if (e.target.tagName === 'INPUT') return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        if (this.audioEngine.isPlaying) {
                            this.pause();
                        } else {
                            this.play();
                        }
                        break;
                    case '+':
                    case '=':
                        this.waveformRenderer.zoomIn();
                        break;
                    case '-':
                        this.waveformRenderer.zoomOut();
                        break;
                }
            }

            async importFile(file) {
                try {
                    this.fileName = file.name;
                    const arrayBuffer = await FileHandler.importFile(file);
                    const audioBuffer = await this.audioEngine.loadAudio(arrayBuffer);

                    if (!this.audioEditor) {
                        this.audioEditor = new AudioEditor(this.audioEngine.audioContext);
                    }

                    this.waveformRenderer.setAudioBuffer(audioBuffer);
                    this.updateUI();
                    this.updateFileInfo();
                    this.updateZoomInfo();
                } catch (err) {
                    alert('Error loading audio file: ' + err.message);
                }
            }

            play() {
                if (!this.audioEngine.audioBuffer) return;

                const selection = this.waveformRenderer.getSelection();
                if (selection && !this.audioEngine.isPaused) {
                    const startTime = selection.start / this.audioEngine.audioBuffer.sampleRate;
                    this.audioEngine.play(startTime);
                } else {
                    this.audioEngine.play();
                }
                this.updateUI();
            }

            pause() {
                this.audioEngine.pause();
                this.updateUI();
            }

            stop() {
                this.audioEngine.stop();
                this.waveformRenderer.setPlayheadPosition(0);
                this.updatePositionInfo(0);
                this.updateUI();
            }

            trim() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                const newBuffer = this.audioEditor.trim(
                    this.audioEngine.audioBuffer,
                    selection.start,
                    selection.end
                );
                this.audioEngine.setBuffer(newBuffer);
                this.waveformRenderer.setAudioBuffer(newBuffer);
                this.updateFileInfo();
            }

            showNormalizeModal() {
                document.getElementById('normalizeModal').classList.add('visible');
            }

            hideNormalizeModal() {
                document.getElementById('normalizeModal').classList.remove('visible');
            }

            normalize() {
                const level = parseFloat(document.getElementById('normalizeLevel').value);
                const selection = this.waveformRenderer.getSelection();

                this.stop();
                if (selection) {
                    this.audioEditor.normalize(this.audioEngine.audioBuffer, level, selection.start, selection.end);
                } else {
                    this.audioEditor.normalize(this.audioEngine.audioBuffer, level);
                }
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.hideNormalizeModal();
            }

            fadeIn() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                this.audioEditor.fadeIn(this.audioEngine.audioBuffer, selection.start, selection.end);
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
            }

            fadeOut() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                this.audioEditor.fadeOut(this.audioEngine.audioBuffer, selection.start, selection.end);
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
            }

            showGainModal() {
                document.getElementById('gainModal').classList.add('visible');
            }

            hideGainModal() {
                document.getElementById('gainModal').classList.remove('visible');
            }

            applyGain() {
                const gainDb = parseFloat(document.getElementById('gainAmount').value);
                const selection = this.waveformRenderer.getSelection();

                this.stop();
                if (selection) {
                    this.audioEditor.applyGain(this.audioEngine.audioBuffer, gainDb, selection.start, selection.end);
                } else {
                    this.audioEditor.applyGain(this.audioEngine.audioBuffer, gainDb);
                }
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.hideGainModal();
            }

            showExportModal() {
                document.getElementById('exportModal').classList.add('visible');
            }

            hideExportModal() {
                document.getElementById('exportModal').classList.remove('visible');
            }

            exportFile() {
                const format = document.getElementById('exportFormat').value;
                const bitDepth = parseInt(document.getElementById('exportBitDepth').value);

                let blob;
                let extension;

                if (format === 'wav') {
                    blob = FileHandler.exportWAV(this.audioEngine.audioBuffer, bitDepth);
                    extension = '.wav';
                } else {
                    // AIF doesn't support 32-bit float
                    const aifBitDepth = bitDepth === 32 ? 24 : bitDepth;
                    blob = FileHandler.exportAIF(this.audioEngine.audioBuffer, aifBitDepth);
                    extension = '.aif';
                }

                const baseName = this.fileName ? this.fileName.replace(/\.[^/.]+$/, '') : 'audio';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = baseName + extension;
                a.click();
                URL.revokeObjectURL(url);

                this.hideExportModal();
            }

            updateUI() {
                const hasAudio = !!this.audioEngine.audioBuffer;
                const hasSelection = this.waveformRenderer.hasSelection();
                const isPlaying = this.audioEngine.isPlaying;

                // File buttons
                document.getElementById('exportBtn').disabled = !hasAudio;

                // Transport
                document.getElementById('playBtn').disabled = !hasAudio;
                document.getElementById('pauseBtn').disabled = !isPlaying;
                document.getElementById('stopBtn').disabled = !hasAudio;
                document.getElementById('playBtn').classList.toggle('playing', isPlaying);

                // Zoom
                document.getElementById('zoomInBtn').disabled = !hasAudio;
                document.getElementById('zoomOutBtn').disabled = !hasAudio;
                document.getElementById('zoomFitBtn').disabled = !hasAudio;

                // Edit (require selection for most)
                document.getElementById('trimBtn').disabled = !hasSelection;
                document.getElementById('normalizeBtn').disabled = !hasAudio;
                document.getElementById('fadeInBtn').disabled = !hasSelection;
                document.getElementById('fadeOutBtn').disabled = !hasSelection;
                document.getElementById('gainBtn').disabled = !hasAudio;
            }

            updateFileInfo() {
                const buffer = this.audioEngine.audioBuffer;
                if (!buffer) {
                    document.getElementById('fileInfo').textContent = 'No file loaded';
                    return;
                }

                const duration = formatTime(buffer.duration);
                const sampleRate = (buffer.sampleRate / 1000).toFixed(1) + ' kHz';
                const channels = buffer.numberOfChannels === 1 ? 'Mono' : 'Stereo';

                document.getElementById('fileInfo').textContent =
                    `${this.fileName} | ${duration} | ${sampleRate} | ${channels}`;
            }

            updatePositionInfo(time) {
                document.getElementById('positionInfo').textContent = formatTime(time);
            }

            updateZoomInfo() {
                const spp = this.waveformRenderer.samplesPerPixel;
                let zoomText;
                if (spp >= 1000) {
                    zoomText = (spp / 1000).toFixed(1) + 'k samples/px';
                } else {
                    zoomText = spp.toFixed(0) + ' samples/px';
                }
                document.getElementById('zoomInfo').textContent = zoomText;
            }
        }

        // Start the application
        const app = new App();
    </script>
</body>
</html>
